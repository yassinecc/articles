# Setting up Stripe on React Native/NodeJS

Stripe is a payment SaaS (Software As A Service) that has gained popularity due to its ease of use for developers and its turnkey handling of PCI compliance. It provides not only a simple way to implement payments on web and mobile, but also fraud detection mechanisms. We are going to see how to implement Stripe credit card payments from the ground up in React Native using the tipsi-stripe library.

### How does it work?

Credit card data is very sensitive information so you won't be handling card numbers and the sort! Instead, you are going to use Stripe objects:

* A **charge** is a transaction record for an amount to be debited from a given credit card. Stripe has implemented a two-step payment flow by allowing users to create uncaptured charges, where Stripe checks with your bank if there are sufficient funds available to carry the transaction and requests to put in on hold for an upcoming payment, and then capturing them which amounts to debiting your account.

{% hint style='info' %}

The biggest advantage of uncaptured charges is that you are guaranteed payment as the bank has confirmed availability of the funds, but you can also instantly release an uncaptured charge instead of waiting 3~5 days for a refund. Note that Stripe charges a fee for captured charges and refunds but releasing an uncaptured charge is free.

{% endhint %}

* A **customer** is the holder of one or multiple means of payment.

* A **token**: this is essentially a representation of your credit card with its information encoded by Stripe using your publishable key. It can only be used once and will be disabled after payment is done.

* A **source** is another representation of your card that can generate recurring payments. It can only be generated by your secret key or directly in the Stripe dashboard.

### What you need to get started

* Create your account on www.stripe.com. In the `Developer` tab, you will see two API keys: a publishable one for your frontend and a secret one for your backend.

{% hint style='info' %}

You can share your publishable key with confidence as it can only create card tokenss. On the other hand, the secret key will handle sensitive operations such as payment, refunds and so on. Store it securely in your server and avoid if possible committing it in versioned source code.

{% endhint %}

* A React Native mobile app

* A backend server. We will use Node in this example but bear in mind that Stripe supports a variety of widely used languages such as Python, PHP, Java and .NET.

### Preparing the backend

In the directory where your `package.json` is located, install the node package provided by Stripe:

```
yarn add stripe
```

The idea is to expose a POST route that will handle payment on the server side. Let's declare a payment route in our Express server:

```code
const express = require('express');
const app = express();
const bodyParser = require('body-parser');

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

const stripeSecretKey = require('./secret.json').stripeSecretKey;

const stripe = require('stripe')($STRIPE_SECRET_KEY);

app.post('/api/doPayment/', (req, res) => {
  return stripe.charges.create({
    amount: req.body.amount, // Unit: cents
    currency: 'eur',
    capture: true,
    source: req.body.tokenId,
  })
  .then(result => res.status(200).json(result))
});
```

The amount to charge is specified in cents for payments in currencies that don't have an irreductible unit, i.e. you can divide a euro in 100 cents. Replace `$STRIPE_SECRET_KEY` with the secret key you can view on https://dashboard.stripe.com/account/apikeys. As mentioned before, a better practice is to import the secret key from an untracked file.

{% hint style='check' %}

Go to THIS STRIPE PAGE to generate a Stripe token with your publishable key, and then try out your route with Postman:

{% endhint %}

### Preparing the front end

There are two options at this point:

* Use the iOS / Android SDKs provided by Stripe
* Use a 3rd party library for React Native: `tipsi-stripe`

There are pros and cons to each path, mainly revolving around the fact that the React Native library from Tipsi has not been publicly approved by Stripe, although you can see into its source code that it does act as a wrapper around Stripe's mobile SDKs. There are rumours going around about Stripe possibly releasing its own official React Native module, however this has not been confirmed. In the rest of this tutorial we are going to use the `tipsi-stripe` library.

Navigate to your app's root directory and install the package:

```
yarn add tipsi-stripe
```

Let us now create a basic payment page, `payment.js`:

```
import React, { Component } from 'react';
import { View, Button } from 'react-native';
import stripe from 'tipsi-stripe';

stripe.init({
  publishableKey: '$YOUR_PUBLIC_KEY',
});

class Payment extends Component {
  constructor() {
    super();
    this.state = {
      isPaymentPending: false,
    };
  }

  requestPayment = () => {
    this.setState({ isPaymentPending: true });
    return stripe.paymentRequestWithCardForm()
      .then((stripeTokenInfo) => {
        console.warn('Token created', { stripeTokenInfo });
      })
      .catch(error => {
        console.warn('Payment failed', { error });
      })
      .finally(() => {
        this.setState({ isPaymentPending: false });
      });
  }

  render() {
    return (
      <View>
        <Button
          title="Make a payment"
          onPress={this.requestPayment}
          disabled={this.state.isPaymentPending}
        >
      </View>
    )
  }
}
```

{% hint style='check %}

You can now generate tokens with your own publishable key and see them in your console. You will be the only one able to create a charge from this token with your secret key.

{% endhint %}

We will now connect our front-end and our backend. I like to group all my API calls in a separate `api.js` file:

```
import axios from 'axios';

export const doPayment = (amount, tokenId, accessToken) => {
  const body = {
    amount: amount,
    tokenId: tokenId,
  };
  const headers = {
    'Content-Type': 'application/json',
  };
  return axios
    .post('http://localhost:5000/api/doPayment', body, { headers })
    .then(({ data }) => {
      return data;
    })
    .catch(error => {
      return Promise.reject('Error in making payment', error);
    });
};
```

I used here the axios library that directly rejects the fetch promise if it has a 40X status. Now we can change the `requestPayment` callback in `payment.js`:

```
requestPayment = () => {
    this.setState({ isPaymentPending: true });
    return stripe.paymentRequestWithCardForm()
      .then(stripeTokenInfo => {
        return doPayment(100, stripeTokenInfo.tokenId)
      })
      .then(() => {
        console.warn('Payment suceeded!')
      })
      .catch(error => {
        console.warn('Payment failed', { error });
      })
      .finally(() => {
        this.setState({ isPaymentPending: false });
      });
  }
```

{% hint style='check' %}

You should now see your first 1â‚¬ payment on the Stripe dashboard

{% endhint %}

### Grouping charges by customer

If you repeat the above example a certain number of times, you will see in your payment history a long list of unrelated charges. If payment is the last step of an authenticated process (as it should be!), this means that you won't be able to associate customers to the payments they have made.

The next step is to charge a specific Stripe `customer` with the payment. We can create a customer with a token using `customers.create({ email: $YOUR_EMAIL, source: $TOKEN_ID, })`. Note that the token will be unusable after that i.e. you won't be able to create a charge with it. Instead, modify your `doPayment` route in the backend:

```
app.post('/api/doPayment/', (req, res) => {
  return stripe.customers.create({
    email: 'test@test.com',
    source: req.body.tokenId
  })
  .then(customer => {
    stripe.charges.create({
      amount: req.body.amount, // Unit: cents
      currency: 'eur',
      capture: true,
      customer: customer.id
      source: customer.default_source.id,
    })
  })
  .then(result => res.status(200).json(result))
});
```

The customer object returned from the first Stripe call has a `default_source` object which is in this case a card object on which the payment will be charged. Now that we are not using a token, we also need to pass the customer's Stripe ID as a reference for the payment to be successful.

{% hint style='check %}

You should now see on your Stripe dashboard new payments connected to a customer whose email is test@test.com

{% endhint %}

Try this a couple of times then head to the `Customers` section of your Stripe dashboard. You will notice that there are as many customers created as the number of calls to `customers.create` you made. There is no unicity constraint on the email value passed. A solution is to create a Stripe customer the first time a user initiates a payment, store its customer ID locally in a database and retrieve this when you initiate another payment with the same user.

Because most payment solutions are implement in a scenario where a user is authenticated, a good practice to recover the Stripe customer ID is to pass an access token to the request that is sent to the user and recover the user from this access token. Your `doPayment` route should look like this in the case of a recurring payment:

```
app.post('/api/doPayment/', (req, res) => {
  let databaseUser = null
  return getDbUser(req.accessToken) // Some method to get a user from the database
  .then(dbUser => {
    databaseUser = dbUser
    return stripe.customers
      .createSource(databaseUser.stripeCustomerId, { source: req.body.tokenId })
  }) // This Stripe service returns a source object
  .then(newSource => {
    return stripe.customers
      .update(databaseUser.stripeCustomerId, { default_source: newSource.id })
  }) // This Stripe service returns a customer object
  .then(stripeCustomer => {
    return stripe.charges.create({
      amount: req.body.amount, // Unit: cents
      currency: 'eur',
      capture: true,
      customer: stripeCustomer.id
      source: stripeCustomer.default_source.id,
    })
  })
  .then(result => res.status(200).json(result))
});
```

To cover both cases, you can factor the logic retrieving a Stripe customer in a separate function:

```
findOrCreateStripeCustomer = (dbUser, tokenId) => {
  if(!!dbUser.stripeCustomerId) {
    return return stripe.customers
      .createSource(dbUser.stripeCustomerId, { source: tokenId })
  }) // This Stripe service returns a source object
  .then(newSource => {
    return stripe.customers
      .update(dbUser.stripeCustomerId, { default_source: newSource.id })
  })
  } else { // First payment
    return stripe.customers.create({
      email: dbUser.email,
      source: tokenId
    })
  }
}
```

The `doPayment` route becomes:

```
app.post('/api/doPayment/', (req, res) => {
  return getDbUser(req.accessToken) // Some method to get a user from the database
  .then(dbUser => {
    findOrCreateStripeCustomer(dbUser, req.body.tokenId)
  }) // This Stripe service returns a customer object
  .then(stripeCustomer => {
    saveDbUser(stripeCustomer.id) // Save your Stripe customer ID for the next time
    return stripe.charges.create({
      amount: req.body.amount, // Unit: cents
      currency: 'eur',
      capture: true,
      customer: stripeCustomer.id
      source: stripeCustomer.default_source.id,
    })
  })
  .then(result => res.status(200).json(result))
});
```

The implementation of a customer database is outside the scope of this article, but you can easily implement a PostgreSQL + Sequelize setup and try out payments with the `findOrCreateStripeCustomer` logic

Check: You can have all payments linked to one customer

